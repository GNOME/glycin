// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files
// DO NOT EDIT

use glib::prelude::*;
use glib::translate::*;

use crate::ffi;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GlyMemoryFormat")]
pub enum MemoryFormat {
    #[doc(alias = "GLY_MEMORY_B8G8R8A8_PREMULTIPLIED")]
    B8g8r8a8Premultiplied,
    #[doc(alias = "GLY_MEMORY_A8R8G8B8_PREMULTIPLIED")]
    A8r8g8b8Premultiplied,
    #[doc(alias = "GLY_MEMORY_R8G8B8A8_PREMULTIPLIED")]
    R8g8b8a8Premultiplied,
    #[doc(alias = "GLY_MEMORY_B8G8R8A8")]
    B8g8r8a8,
    #[doc(alias = "GLY_MEMORY_A8R8G8B8")]
    A8r8g8b8,
    #[doc(alias = "GLY_MEMORY_R8G8B8A8")]
    R8g8b8a8,
    #[doc(alias = "GLY_MEMORY_A8B8G8R8")]
    A8b8g8r8,
    #[doc(alias = "GLY_MEMORY_R8G8B8")]
    R8g8b8,
    #[doc(alias = "GLY_MEMORY_B8G8R8")]
    B8g8r8,
    #[doc(alias = "GLY_MEMORY_R16G16B16")]
    R16g16b16,
    #[doc(alias = "GLY_MEMORY_R16G16B16A16_PREMULTIPLIED")]
    R16g16b16a16Premultiplied,
    #[doc(alias = "GLY_MEMORY_R16G16B16A16")]
    R16g16b16a16,
    #[doc(alias = "GLY_MEMORY_R16G16B16_FLOAT")]
    R16g16b16Float,
    #[doc(alias = "GLY_MEMORY_R16G16B16A16_FLOAT")]
    R16g16b16a16Float,
    #[doc(alias = "GLY_MEMORY_R32G32B32_FLOAT")]
    R32g32b32Float,
    #[doc(alias = "GLY_MEMORY_R32G32B32A32_FLOAT_PREMULTIPLIED")]
    R32g32b32a32FloatPremultiplied,
    #[doc(alias = "GLY_MEMORY_R32G32B32A32_FLOAT")]
    R32g32b32a32Float,
    #[doc(alias = "GLY_MEMORY_G8A8_PREMULTIPLIED")]
    G8a8Premultiplied,
    #[doc(alias = "GLY_MEMORY_G8A8")]
    G8a8,
    #[doc(alias = "GLY_MEMORY_G8")]
    G8,
    #[doc(alias = "GLY_MEMORY_G16A16_PREMULTIPLIED")]
    G16a16Premultiplied,
    #[doc(alias = "GLY_MEMORY_G16A16")]
    G16a16,
    #[doc(alias = "GLY_MEMORY_G16")]
    G16,
    #[doc(hidden)]
    __Unknown(i32),
}

impl MemoryFormat {
    #[doc(alias = "gly_memory_format_has_alpha")]
    pub fn has_alpha(self) -> bool {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::gly_memory_format_has_alpha(self.into_glib())) }
    }

    #[doc(alias = "gly_memory_format_is_premultiplied")]
    pub fn is_premultiplied(self) -> bool {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::gly_memory_format_is_premultiplied(self.into_glib())) }
    }
}

#[doc(hidden)]
impl IntoGlib for MemoryFormat {
    type GlibType = ffi::GlyMemoryFormat;

    fn into_glib(self) -> ffi::GlyMemoryFormat {
        match self {
            Self::B8g8r8a8Premultiplied => ffi::GLY_MEMORY_B8G8R8A8_PREMULTIPLIED,
            Self::A8r8g8b8Premultiplied => ffi::GLY_MEMORY_A8R8G8B8_PREMULTIPLIED,
            Self::R8g8b8a8Premultiplied => ffi::GLY_MEMORY_R8G8B8A8_PREMULTIPLIED,
            Self::B8g8r8a8 => ffi::GLY_MEMORY_B8G8R8A8,
            Self::A8r8g8b8 => ffi::GLY_MEMORY_A8R8G8B8,
            Self::R8g8b8a8 => ffi::GLY_MEMORY_R8G8B8A8,
            Self::A8b8g8r8 => ffi::GLY_MEMORY_A8B8G8R8,
            Self::R8g8b8 => ffi::GLY_MEMORY_R8G8B8,
            Self::B8g8r8 => ffi::GLY_MEMORY_B8G8R8,
            Self::R16g16b16 => ffi::GLY_MEMORY_R16G16B16,
            Self::R16g16b16a16Premultiplied => ffi::GLY_MEMORY_R16G16B16A16_PREMULTIPLIED,
            Self::R16g16b16a16 => ffi::GLY_MEMORY_R16G16B16A16,
            Self::R16g16b16Float => ffi::GLY_MEMORY_R16G16B16_FLOAT,
            Self::R16g16b16a16Float => ffi::GLY_MEMORY_R16G16B16A16_FLOAT,
            Self::R32g32b32Float => ffi::GLY_MEMORY_R32G32B32_FLOAT,
            Self::R32g32b32a32FloatPremultiplied => {
                ffi::GLY_MEMORY_R32G32B32A32_FLOAT_PREMULTIPLIED
            }
            Self::R32g32b32a32Float => ffi::GLY_MEMORY_R32G32B32A32_FLOAT,
            Self::G8a8Premultiplied => ffi::GLY_MEMORY_G8A8_PREMULTIPLIED,
            Self::G8a8 => ffi::GLY_MEMORY_G8A8,
            Self::G8 => ffi::GLY_MEMORY_G8,
            Self::G16a16Premultiplied => ffi::GLY_MEMORY_G16A16_PREMULTIPLIED,
            Self::G16a16 => ffi::GLY_MEMORY_G16A16,
            Self::G16 => ffi::GLY_MEMORY_G16,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GlyMemoryFormat> for MemoryFormat {
    unsafe fn from_glib(value: ffi::GlyMemoryFormat) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GLY_MEMORY_B8G8R8A8_PREMULTIPLIED => Self::B8g8r8a8Premultiplied,
            ffi::GLY_MEMORY_A8R8G8B8_PREMULTIPLIED => Self::A8r8g8b8Premultiplied,
            ffi::GLY_MEMORY_R8G8B8A8_PREMULTIPLIED => Self::R8g8b8a8Premultiplied,
            ffi::GLY_MEMORY_B8G8R8A8 => Self::B8g8r8a8,
            ffi::GLY_MEMORY_A8R8G8B8 => Self::A8r8g8b8,
            ffi::GLY_MEMORY_R8G8B8A8 => Self::R8g8b8a8,
            ffi::GLY_MEMORY_A8B8G8R8 => Self::A8b8g8r8,
            ffi::GLY_MEMORY_R8G8B8 => Self::R8g8b8,
            ffi::GLY_MEMORY_B8G8R8 => Self::B8g8r8,
            ffi::GLY_MEMORY_R16G16B16 => Self::R16g16b16,
            ffi::GLY_MEMORY_R16G16B16A16_PREMULTIPLIED => Self::R16g16b16a16Premultiplied,
            ffi::GLY_MEMORY_R16G16B16A16 => Self::R16g16b16a16,
            ffi::GLY_MEMORY_R16G16B16_FLOAT => Self::R16g16b16Float,
            ffi::GLY_MEMORY_R16G16B16A16_FLOAT => Self::R16g16b16a16Float,
            ffi::GLY_MEMORY_R32G32B32_FLOAT => Self::R32g32b32Float,
            ffi::GLY_MEMORY_R32G32B32A32_FLOAT_PREMULTIPLIED => {
                Self::R32g32b32a32FloatPremultiplied
            }
            ffi::GLY_MEMORY_R32G32B32A32_FLOAT => Self::R32g32b32a32Float,
            ffi::GLY_MEMORY_G8A8_PREMULTIPLIED => Self::G8a8Premultiplied,
            ffi::GLY_MEMORY_G8A8 => Self::G8a8,
            ffi::GLY_MEMORY_G8 => Self::G8,
            ffi::GLY_MEMORY_G16A16_PREMULTIPLIED => Self::G16a16Premultiplied,
            ffi::GLY_MEMORY_G16A16 => Self::G16a16,
            ffi::GLY_MEMORY_G16 => Self::G16,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for MemoryFormat {
    #[inline]
    #[doc(alias = "gly_memory_format_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gly_memory_format_get_type()) }
    }
}

impl glib::HasParamSpec for MemoryFormat {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for MemoryFormat {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MemoryFormat {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for MemoryFormat {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MemoryFormat> for glib::Value {
    #[inline]
    fn from(v: MemoryFormat) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GlySandboxSelector")]
pub enum SandboxSelector {
    #[doc(alias = "GLY_SANDBOX_SELECTOR_AUTO")]
    Auto,
    #[doc(alias = "GLY_SANDBOX_SELECTOR_BWRAP")]
    Bwrap,
    #[doc(alias = "GLY_SANDBOX_SELECTOR_FLATPAK_SPAWN")]
    FlatpakSpawn,
    #[doc(alias = "GLY_SANDBOX_SELECTOR_NOT_SANDBOXED")]
    NotSandboxed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SandboxSelector {
    type GlibType = ffi::GlySandboxSelector;

    #[inline]
    fn into_glib(self) -> ffi::GlySandboxSelector {
        match self {
            Self::Auto => ffi::GLY_SANDBOX_SELECTOR_AUTO,
            Self::Bwrap => ffi::GLY_SANDBOX_SELECTOR_BWRAP,
            Self::FlatpakSpawn => ffi::GLY_SANDBOX_SELECTOR_FLATPAK_SPAWN,
            Self::NotSandboxed => ffi::GLY_SANDBOX_SELECTOR_NOT_SANDBOXED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GlySandboxSelector> for SandboxSelector {
    #[inline]
    unsafe fn from_glib(value: ffi::GlySandboxSelector) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GLY_SANDBOX_SELECTOR_AUTO => Self::Auto,
            ffi::GLY_SANDBOX_SELECTOR_BWRAP => Self::Bwrap,
            ffi::GLY_SANDBOX_SELECTOR_FLATPAK_SPAWN => Self::FlatpakSpawn,
            ffi::GLY_SANDBOX_SELECTOR_NOT_SANDBOXED => Self::NotSandboxed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SandboxSelector {
    #[inline]
    #[doc(alias = "gly_sandbox_selector_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gly_sandbox_selector_get_type()) }
    }
}

impl glib::HasParamSpec for SandboxSelector {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for SandboxSelector {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SandboxSelector {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SandboxSelector {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SandboxSelector> for glib::Value {
    #[inline]
    fn from(v: SandboxSelector) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
